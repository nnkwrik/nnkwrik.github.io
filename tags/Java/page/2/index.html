<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="曽生">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="曽生">
    
    <meta name="keywords" content="nnkwrik,曽生,曾丽桦,野々川麗樺">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>农场主的黑科技.</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin="">
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin="">
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"输入关键字 :D","hits_empty":"没有找到相关信息 :(","hits_stats":"找到 ${hits} 个相关信息,耗时 ${time} ms"}')

            var algolia = {
                applicationID: 'LXR3VBZBS6',
                apiKey: '17d6d4ab4ba943bab3232eced0eea766',
                indexName: 'index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <a class="home-link" href="/">农场主的黑科技.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="






">
    
    <!-- 主页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
        </p>
        <!-- 文章页meta -->
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main index-page">
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/01/20181101-2/">
            
                <span>并发操作合集-4.Lcok和Condition</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

并发API支持多种显式的锁，它们由Lock接口规定，用于代替synchronized的隐式锁。锁对细粒度的控制支持多种方法，因此它们比隐式的监视器具有更大的开销。
Lock接口和synchronized关键字的差别两者的区别如下：



类别
synchronized
Lock




存在层次
Java的关键字，在jvm层面上
是一个类


锁的释放
1、以获取锁的线程执行完同步代码，释放锁2、线程执行发生异常，jvm会让线程释放锁
在finally中必须释放锁，不然容易造成线程死锁


锁的获取
假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待
分情况而定，Lock有多个锁获锁的方式，大致就是可以尝试获得锁，线程可以不用一直等待


锁状态
无法判断
可以判断


锁类型
可重入 不可中断 非公平
可重入 可中断 可公平（两者皆可）


性能
少量同步
大量同步



表中提到了所类型，先了解一下锁类型都有哪些：

可重入锁：在执行对象中所有同步方法不用再次获得锁
可中断锁：在等待获取锁过程中可中断
公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利
读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写

Lock接口定义的方法和使用
lock()：获取锁，如果锁被暂用则一直等待

unlock():释放锁

tryLock(): 注意返回类型是boolean，如果获取锁的时候锁被占用就返回false，否则返回true

tryLock(long time, TimeUnit unit)：比起tryLock()就是给了一个时间期限，保证等待参数时间

lockInterruptibly()：锁的获得方式，如果线程在获取锁的阶段进入了等待，那么可以中断此线程，先去做别的事


通过 以上的解释，大致可以解释在上个部分中“锁类型(lockInterruptibly())”，“锁状态(tryLock())”等问题，还有就是前面子所获取的过程我所写的“大致就是可以尝试获得锁，线程可以不会一直等待”用了“可以”的原因。
简单看一下比较常用的lock()和tryLock()方法的使用方式,启动两个线程来调用这些方法：
l...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/01</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/01/20181101/">
            
                <span>并发操作合集-3.Synchronized使用指南</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

这篇文章将告诉你如何正确的使用synchronized关键字。通过示例代码彻底了解synchronized关键字的使用规则和一些隐患。
1.Java的锁1.1 锁的内存语义
锁可以让临界区互斥执行，还可以让释放锁的线程向同一个锁的线程发送消息
锁的释放要遵循Happens-before原则（锁规则：解锁必然发生在随后的加锁之前）
锁在Java中的具体表现是 Synchronized 和 Lock

2.Synchronized的综述
同步机制： synchronized是Java同步机制的一种实现，即互斥锁机制，它所获得的锁叫做互斥锁
互斥锁： 指的是每个对象的锁一次只能分配给一个线程，同一时间只能由一个线程占用
作用： synchronized用于保证同一时刻只能由一个线程进入到临界区，同时保证共享变量的可见性、原子性和有序性
使用： 当一个线程试图访问同步代码方法(块)时，它首先必须得到锁，退出或抛出异常时必须释放锁

3.Synchronized的使用3.1 Synchronized的三种应用方式

补充： 使用同步代码块的好处在于其他线程仍可以访问非synchronized(this)的同步代码块

3.2 Synchronized的使用规则123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/**  * 先定义一个测试模板类  *     这里补充一个知识点：Thread.sleep(long)不会释放锁  *     读者可参见笔者的`并发番@Thread一文通`  */ public class SynchronizedDemo &#123;    public static synchronized void staticMethod()&#123;        System.out.println(Thread.currentThread()....
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/01</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/01/20181031/">
            
                <span>并发操作合集-2.状态转换方法：wait,notify,sleep,join,yield</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

这篇文章中会详细介绍那些切换线程状态的常用方法(wait,notify,sleep,join,yield)。
线程的状态和常用方法还是这张图。本章中介绍的方法与线程状态的关系如下图所示

wait() 和 notify() 方法首先，这两个方法是做什么的：

Object.wait() – 挂起一个线程
Object.notify() – 唤醒一个线程

wait()使当前线程阻塞，前提是 必须先获得锁，所以通常在synchronized 同步代码块里使用 wait()，notify/notifyAll() 方法。
当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。此时的等待状态和sleep造成的等待状态稍有不同，下一章会对此进行解释。
当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码。如果中途遇到wait() ，将再次释放锁。
也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，此时被唤醒的等待线状态的线程将会变为阻塞状态（BLOCKED）位于对象的等待锁定池，直到notify释放锁并获取该锁。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程 。
另外wait() 需要被try catch包围，中断也可以使wait等待的线程唤醒。
notify 和 notifyAll的区别 ： notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。
示例：发送者 - 接收者同步问题假如有这样的需求：

发送者会向接收者发送数据包
在发送者完成发送之前，接收者无法处理数据包
同样，发送者不得尝试发送另一个数据包，直到接收者已处理完上一个数据包

创建一个Data类来实现这些数据包的操作
123456789...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/01</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/01/20181030-2/">
            
                <span>并发操作合集-1.线程的生命周期</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

在介绍并发的操作之前，必需先理解线程的生命周期。
线程的生命周期下图是Java中线程的生命周期，以及切换状态的常用方法。java.lang.Thread类包含的状态枚举定义了这6个状态。

不管在任何时候，线程会是以下状态的其中一个：

New（新建状态)当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();
Runnable（可运行状态)可运行状态中分为就绪状态和运行状态。

就绪（Ready to Run）当调用线程对象的start()方法（t.start();），线程即进入已就绪的状态。处于此状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；

运行（Running）当CPU开始调度处于就绪的线程时，此时线程才得以真正执行，即进入到此状态。注意，就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；



Wating / Timed Wating（等待状态 / 限时等待状态）等待状态分为释放锁的等待和不释放锁的等待。
释放锁运行状态中的线程执行wait()方法和join()方法，使线程进入到此状态。过程会释放锁
不释放锁 通过调用线程的sleep()方法，使线程进入到此状态。过程不会释放锁。


Blocked（阻塞状态）阻塞状态是指在对象的等待锁定池中，等待该对象的锁时的状态。当一个对象尝试访问synchronized块时会处于此状态。
Terminated（终止状态）线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

下面通过代码来模拟这些状态
New可以用start()方法去启动一个状态为NEW的线程
123Runnable runnable = new NewState();Thread t = new Thread(runnable);Log.info(t.getState());	//输出 NEW
Runnable当我们对一个状态为NEW的线程调用start()方法，他就会变成RUNNABLE状态。在这个状态中，运行中或已经处于已做好准备，一旦获得资源就能运行。
在多线程环境中，线程调度器为每个线程分配固定的时间...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/01</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/10/30/20181030/">
            
                <span>Java并发编程实战-第6章-任务执行</span>
        </a>
        <div class="abstract-content">
            什么是任务？任务就是工作单元，我们把应用中的工作分成多个任务，从而进行事务操作和并行工作。
在线程中执行任务首先任务之间必须是相互独立的：任务并不依赖于其他任务的状态，结果或边界效应。 
串行地执行任务有多种调度任务的策略，而其中一些策略能够更好地利用潜在并发性。
策略1 ： 在单个线程中串行地执行各项任务，也就是按顺序一个个执行。
😕 串行Web服务器
12345678910//         6-1  串行的Web服务器（并不好）public class SingleThreadWebServer &#123;    public static void main(String[] args) throws IOException &#123;        ServerSocket socket = new ServerSocket(80);        while (true) &#123;      //处理多个请求            Socket connection = socket.accept();//通过80端口接收到HTTP请求            handleRequest(connection); //处理请求        &#125;    &#125;&#125;
上面的服务器程序中，一次只能处理一个请求，性能非常差。当等待时间过长时，客户端会认为服务器没有响应，而且服务器cpu资源利用非常低。对于服务器而言这种串行执行的方式无疑是不合适的。
显示地为任务创建线程策略2 ： 通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性。
😧 为每个请求启动一个新的线程
123456789101112131415//     6-2   在Web服务器中为每个请求启动一个新的线程（不要这么做）public class ThreadPerTaskWebServer &#123;    public static void main(String[] args) throws IOException &#123;        ServerSocket socket = new ServerSocket(80);        while (true) &#123;  //多个请求            final S...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/10/30</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="《Java并发编程实战》">《Java并发编程实战》</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/10/29/20181029/">
            
                <span>Java并发编程实战-第5章-基础构建模块</span>
        </a>
        <div class="abstract-content">
            本章中讲介绍在Java5和6中引入的一些构建并发模块，以及如何用这些模块来进行开发。
同步容器类同步容器类包括Vector和Hashtable、这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。
同步容器类的问题常见的复合操作包括：

迭代（反复访问元素，知道遍历容器中所有元素）
跳转（根据指定顺序找到当前元素的下个元素）
条件运算：例如“若没有则添加”。在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。

:confused:
123456789//           5-1    Vector上可能导致混乱结果的复合操作public static Object getLast(Vector list) &#123;    int lastIndex = list.size() - 1;    return list.get(lastIndex);&#125;public static void deleteLast(Vector list) &#123;     int lastIndex = list.size() - 1;     list.remove(lastIndex);&#125;
上面是Vector中定义的两个方法，它们都会执行“先检查再运行”操作，每个方法首先都获得数组的大小，然后通过结果来获取或删除最后一个元素。
如果线程A在包含10个元素的Vector上调用removeLast，同时线程B调用getLast，这个时候就会出现下面的情况，并抛出ArrayIndexOutOfBoundsException。

:blush: 把上面的程序改成客户端加锁，通过list自身的锁来保护他，使getLast和deleteLast成为原子操作
12345678910111213//              5-2    在使用客户端加锁的Vector上的复合操作public static Object getLast(Vector list) &#123;        synchronized (list) &#123;         //获得容器类的锁，从客户端得到        int las...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/10/29</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="《Java并发编程实战》">《Java并发编程实战》</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/10/28/20181028/">
            
                <span>Java并发编程实战-第4章-对象的组合</span>
        </a>
        <div class="abstract-content">
            在本章中涉及的组合模式中，将会把一些现有的线程安全组件组合成更大的程序，从而实现线程安全。
设计线程安全的类我们可以通过封装来确保程序是线程安全的。线程安全的类的设计过程：

找出构成对象状态的所有属性
找出约束这些属性的不变性条件
建立这些属性的并发访问策略（同步策略）

比如我们想要设计出下面这样的线程安全的程序，需要什么样的过程？
1234567891011121314@ThreadSafepublic final class Counter &#123;    @GuardedBy("this") private long value = 0;    public synchronized long getValue() &#123;        return value;    &#125;    public synchronized long increment() &#123;        if (value == Long.MAX_VALUE)            throw new IllegalStateException("counter overflow");        return ++value;    &#125;&#125;
首先，一目了然的是：
设计步骤1 : 只有value属性
第三步的同步策略(Synchronized Policy)定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。为了规定同步策略，我们需要先找出对象的不变条件或后验条件等同步需求。
收集同步需求
不可变条件 ： 用于来判断状态是否有效。设计步骤2.1 ： value属性是long类型，所以他的状态必需是Long.MIN_VALUE到Long.MAX_VALUE，并且在目前的代码中value属性不能是负值。

后验条件：来判断状态迁移是否是有效。
也就是说，当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作（读取-修改-写入）。
设计步骤2.2 ： 如果Counter的当前值为17，那么下一个有效状态只能是18。必须是复合操作

先验条件 ： 某些对象的方法中还包含一些基于状态的先验条件。比如不能从空队列中移除元素，这种就是依赖状态的操作。

状态的所有权 ： 一个对象的状态将是对象图中所有对象包含的域的一个...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/10/28</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="《Java并发编程实战》">《Java并发编程实战》</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/10/27/20181027/">
            
                <span>Java并发编程实战-第3章-对象的共享</span>
        </a>
        <div class="abstract-content">
            在上一章中介绍了如何通过同步来避免多个线程在同一时间访问相同数据，在这一章中将介绍如何共享和发布对象，从而能安全地被多个线程同时访问。
可见性什么是内存可见性？可见性就是值一个线程修改了对象状态之后，其他线程能够看到发生的状态变化。然而，通常无法确定读操作的线程能适时地看见其他线程写入的值，所以需要同步。
:anguished: 在没有同步情况下的共享变量
123456789101112131415161718public class NoVisibility &#123;    private static boolean ready;    private static int number;    private static class ReaderThread extends Thread &#123;        public void run() &#123;            while (!ready)                Thread.yield();            System.out.println(number);        &#125;    &#125;    public static void main(String[] args) &#123;        new ReaderThread().start();        number = 42;        ready = true;    &#125;&#125;
在上面的代码中，看起来会输出42，但很可能会输出0，甚至无法终止。因为无法保证main写入的值对于读线程来说是可见的。输出0的状况被称为重排序，可能在读程序眼中，number和ready的写入程序甚至可能是相反的。因为在没有同步的情况下，编译器等会对执行顺序进行调整。
失效数据失效数据是指，当读线程去读某个数据的时候，可能读到的是一个已经过期的旧值。在糟糕的情况下，可能读到的两个值中，一个是新的值但另一个是过期的值。
:confused: 非线程安全的getter,setter
123456@NotThreadSafepublic class MutableInteger &#123;    private int value;    public int get() &#1...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/10/27</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="《Java并发编程实战》">《Java并发编程实战》</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/10/25/20181025/">
            
                <span>Java并发编程实战-第2章-线程安全性</span>
        </a>
        <div class="abstract-content">
            编写线程安全的代码 就是对共享的和可变的状态访问操作进行管理。那么什么是状态？
状态是指存储在状态变量总的数据。比如某个HashMap的状态，不仅是HashMap本身,也包括存储的Map.Entry对象。对外部有影响的数据都能称为是状态。

共享的 : 可以被多个线程同时访问的变量
可变的 : 变量的值在生命周期内可以发生变化

如果一个对象会被多个线程同时访问，那么他就需要是线程安全的，因此需要采用同步机制来协同对象可变状态的访问。如果不能协同，那么就有可能产生不该出现的结果。

防止发生线程不安全的状况 : 1. 不在线程之间共享该状态变量 2. 将状态变量修改为不可变的变量 3. 在访问状态变量时使用同步

另外，程序的封装性越好，就越容易实现程序的线程安全性，且更容易维护。
什么是线程安全性
线程安全性 : 当多个线程访问某个类使,这个类始终都能表现出正确的行为,那么就称这个类为线程安全的


无状态的对象一定是线程安全的.

:blush: 一个无状态的Servlet
123456789@ThreadSafepublic class StatelessFactorizer extends GenericServlet implements Servlet &#123;    public void service(ServletRequest req, ServletResponse resp) &#123;        BigInteger i = extractFromRequest(req);        BigInteger[] factors = factor(i);        encodeIntoResponse(resp, factors);    &#125;&#125;
在这个Servlet中，不包含任何变量，也不包含其他类的变量。计算过程中的临时状态都存于局部变量中，并且只能由当前线程访问。所以访问Servlet的线程不会影响到另一个同时访问Servlet的计算结果。因为他们没有共享状态。
原子性:anguished: 一个线程不安全的Hit Counter程序
123456789101112131415@NotThreadSafepublic class UnsafeCountingFactorizer extends ...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/10/25</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="《Java并发编程实战》">《Java并发编程实战》</a>
    
</div>
            
        </div>
    </article>
    
    <!-- paginator  -->
    
    <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/tags/Java/">&#60; PREV</a><a class="page-number" href="/tags/Java/">1</a><span class="page-number current">2</span>
    </nav>
    
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:nnkwrik@gmail.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="//github.com/nnkwrik" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title="wechat">
                  
                  <img class="profile-qr" src="/assets/qr.png">
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 19
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger">
                <span class="iconfont-archer search-icon">&#xe627;</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/09</span><a class="archive-post-title" href="/2018/11/09/20181109/">深入理解Java虚拟机-第1章-走近Java</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/05</span><a class="archive-post-title" href="/2018/11/05/20181105/">Java并发编程实战-第7章-取消与关闭</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104-5/">🍤 并发操作合集-目录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104-4/">并发操作合集-11.ThreadLocal</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104-3/">并发操作合集-10.Executor和线程池</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104-2/">并发操作合集-9.并发工具：Semaphore,CountDownLatch,CyclicBarrier</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104/">并发操作合集-8.并发容器：CopyOnWriteArrayList</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181102-3/">并发操作合集-7.并发容器：BlockingQueue</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/02</span><a class="archive-post-title" href="/2018/11/02/20181102-2/">并发操作合集-6.并发容器：ConcurrentHashMap</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/02</span><a class="archive-post-title" href="/2018/11/02/20181102/">并发操作合集-5.原子变量和volatile</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span><a class="archive-post-title" href="/2018/11/01/20181030-2/">并发操作合集-1.线程的生命周期</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span><a class="archive-post-title" href="/2018/11/01/20181031/">并发操作合集-2.状态转换方法：wait,notify,sleep,join,yield</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span><a class="archive-post-title" href="/2018/11/01/20181101/">并发操作合集-3.Synchronized使用指南</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span><a class="archive-post-title" href="/2018/11/01/20181101-2/">并发操作合集-4.Lcok和Condition</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/30</span><a class="archive-post-title" href="/2018/10/30/20181030/">Java并发编程实战-第6章-任务执行</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/29</span><a class="archive-post-title" href="/2018/10/29/20181029/">Java并发编程实战-第5章-基础构建模块</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href="/2018/10/28/20181028/">Java并发编程实战-第4章-对象的组合</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href="/2018/10/27/20181027/">Java并发编程实战-第3章-对象的共享</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/25</span><a class="archive-post-title" href="/2018/10/25/20181025/">Java并发编程实战-第2章-线程安全性</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="并发"><span class="iconfont-archer">&#xe606;</span>并发</span>
    
        <span class="sidebar-tag-name" data-tags="并发操作合集"><span class="iconfont-archer">&#xe606;</span>并发操作合集</span>
    
        <span class="sidebar-tag-name" data-tags="JVM"><span class="iconfont-archer">&#xe606;</span>JVM</span>
    
        <span class="sidebar-tag-name" data-tags="《深入理解Java虚拟机》"><span class="iconfont-archer">&#xe606;</span>《深入理解Java虚拟机》</span>
    
        <span class="sidebar-tag-name" data-tags="《Java并发编程实战》"><span class="iconfont-archer">&#xe606;</span>《Java并发编程实战》</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="并发操作合集"><span class="iconfont-archer">&#xe60a;</span>并发操作合集</span>
    
        <span class="sidebar-category-name" data-categories="读书笔记"><span class="iconfont-archer">&#xe60a;</span>读书笔记</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "曽生"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
     
    </body>
</html>


