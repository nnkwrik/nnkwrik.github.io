<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="曽生">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="曽生">
    
    <meta name="keywords" content="nnkwrik,曽生,曾丽桦,野々川麗樺">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>农场主的黑科技.</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin="">
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin="">
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"输入关键字 :D","hits_empty":"没有找到相关信息 :(","hits_stats":"找到 ${hits} 个相关信息,耗时 ${time} ms"}')

            var algolia = {
                applicationID: 'LXR3VBZBS6',
                apiKey: '17d6d4ab4ba943bab3232eced0eea766',
                indexName: 'index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <a class="home-link" href="/">农场主的黑科技.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="






">
    
    <!-- 主页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
        </p>
        <!-- 文章页meta -->
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main index-page">
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/05/20181105/">
            
                <span>Java并发编程实战-第7章-取消与关闭</span>
        </a>
        <div class="abstract-content">
            本章将给出各种实现取消和中断的机制，以及如何编写任务和服务，使它们能对取消请求做出响应。
任务取消可取消的操作 ：　外部代码能在某个操作正常完成之前将其置入“完成”状态
取消某个操作的原因：

点击某个桌面应用中的取消按钮时； 
某个操作超过了一定的执行时间限制需要中止时； 
多个线程做相同的事情，只要一个线程成功其它线程都可以取消时； 
一组线程中的一个或多个出现错误导致整组都无法继续时； 
当一个应用或服务需要停止时。

Java中没有一种安全的抢占式方法来停止线程，只有一些协作式的机制，代码都会遵循的一种协议。
比如：

“已请求取消”标志
任务将定期地查看这个标志。如果设置了这个标志，那么任务将提前结束。

😊PrimeGenerator持续地枚举素数（Prime），直到cancelled被设置。为了确保可靠性cancelled被设置为volatile。
123456789101112131415161718192021222324//        7-1      使用Volatile类型的域来保存取消状态  public class PrimeGenerator implements Runnable&#123;    private final List&lt;BigInteger&gt; primes=            new ArrayList&lt;BigInteger&gt;();    private volatile boolean cancelled;//volatile变量能确保可见性 禁止指令重排序    public void run()&#123;        BigInteger p=BigInteger.ONE;//常量        while(!cancelled)&#123;  //任务将定期地查看这个标志。如果设置了这个标志，那么任务将提前结束。（即如果cancelled不为true则一直运行）            p=p.nextProbablePrime();//返回一个比当前大的            synchronized (this) &#123; //确保不会被添加多次                primes.add(p);            &#125;        &#1...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/05</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="《Java并发编程实战》">《Java并发编程实战》</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/04/20181104-5/">
            
                <span>🍤 并发操作合集-目录</span>
        </a>
        <div class="abstract-content">
            并发操作合集这是一个关于并发的系列。以实战为驱动，了解并发编程中的那些骚操作。文中的示例代码和部分解释来源于网络，你可以把这个系列当做一本工具书，想不起来的时候来看一看，顺便star一发也是可以的。
对于并发，我目前也在摸索的过程中，写这个系列的目的主要是为了巩固知识。如果有不对的地方还望大佬们指正！

🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

大纲


章节
源码位置




1.线程的生命周期
threadlifecycle


2.状态转换方法：wait,notify,sleep,join,yield
threadStateMethod


3.Synchronized使用指南
synchronizedKeyword


4.Lcok和Condition
lock


5.原子变量和volatile
atomicVolatile


6.并发容器：ConcurrentHashMap
concurrentMap


7.并发容器：BlockingQueue
blockingQueue


8.并发容器：CopyOnWriteArrayList
copyOnWriteArrayList


9.并发工具：Semaphore,CountDownLatch,CyclicBarrier
concurrentUtils


10.Executor和线程池
executor


11.ThreadLocal
threadLocal


12.Java8：并发流



13.Java8：CompletableFuture



番外篇


章节
源码位置




并发的N种解法：生产者消费者问题



并发的N种解法：哲♂学家进餐




不定期更新…


        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/04</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/04/20181104-4/">
            
                <span>并发操作合集-11.ThreadLocal</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

ThreadLocal的用法ThreadLocal用于保存某个线程共享变量：对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。

ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。

ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。

ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。

ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。


示例代码：
1234567891011121314151617181920212223242526private static final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();public static void main(String[] args) throws InterruptedException &#123;    Runnable task1 = () -&gt; &#123;        threadLocal.set(Instant.now().toString());        try &#123;            TimeUnit.SECONDS.sleep(3);            System.out.println(Thread.currentThread().getName() + " ==&gt; " + threadLocal.get());        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;;    ExecutorService executorService = Executors.newFixedThreadPool(10);    for (int ...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/04</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/04/20181104-3/">
            
                <span>并发操作合集-10.Executor和线程池</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

Executor并发API引入了ExecutorService作为一个在程序中直接使用Thread的高层次的替换方案。Executos支持运行异步任务，通常管理一个线程池，这样一来我们就不需要手动去创建新的线程。在不断地处理任务的过程中，线程池内部线程将会得到复用，因此，在我们可以使用一个executor service来运行和我们想在我们整个程序中执行的一样多的并发任务。
下面是使用executors的第一个代码示例：
123456ExecutorService executor = Executors.newSingleThreadExecutor();executor.submit(() -&gt; &#123;String threadName = Thread.currentThread().getName();System.out.println("Hello " + threadName);&#125;);// =&gt; Hello pool-1-thread-1
Executors类提供了便利的工厂方法来创建不同类型的 executor services。在这个示例中我们使用了一个单线程线程池的 executor。
代码运行的结果类似于上一个示例，但是当运行代码时，你会注意到一个很大的差别：Java进程从没有停止！Executors必须显式的停止-否则它们将持续监听新的任务。
ExecutorService提供了两个方法来达到这个目的——shutdwon()会等待正在执行的任务执行完而shutdownNow()会终止所有正在执行的任务并立即关闭execuotr。
这是我喜欢的通常关闭executors的方式：
1234567891011121314try &#123;    System.out.println("尝试终止executor");    executor.shutdown();    executor.awaitTermination(5, TimeUnit.SECONDS);// 5秒内尝试终止,期间会阻塞当前线程&#125; catch (InterruptedException e) &#123;    System.err.println("终止行为被中断...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/04</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/04/20181104-2/">
            
                <span>并发操作合集-9.并发工具：Semaphore,CountDownLatch,CyclicBarrier</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

这篇文章会介绍3中非常实用的并发工具，Semaphore，CountDownLatch，CyclicBarrier。
SemaphoreSemaphore可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。Semaphore就相当于一个许可证，线程需要先通过acquire方法获取该许可证，该线程才能继续往下执行，否则只能在该方法出阻塞等待。当执行完业务功能后，需要通过release()方法将许可证归还，以便其他线程能够获得许可证继续执行。
Semaphore可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。假如有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有3个，这时候就需要使用Semaphore来控制能够并发访问到数据库连接资源的线程个数最多只有3个。在限制资源使用的应用场景下，Semaphore是特别合适的。
下面来看下Semaphore的主要方法：

acquire() ： 获取许可，如果无法获取到，则阻塞等待直至能够获取为止

tryAcquire()： 获取许可，如果许可立即可用则返回true并获取否则返回false

release() ： 释放许可
availablePermits() : 返回当前可用的许可证个数
hasQueuedThreads() : 是否有线程正在等待获取许可证
getQueuedThreads() : 获取所有正在等待许可的线程集合

另外，在Semaphore的构造方法中还支持指定是够具有公平性，默认的是非公平性，这样也是为了保证吞吐量。
示例程序看一个示例：
123456789101112131415161718192021222324252627282930313233Runnable runnable = () -&gt; &#123;    try &#123;        semaphore.acquire();        System.out.println(Thread.currentThread().getName() + " =====&gt; 获取许可");        System.out.println(Thread.currentThre...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/04</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/04/20181104/">
            
                <span>并发操作合集-8.并发容器：CopyOnWriteArrayList</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

这一篇文章也会介绍一个并发容器，CopyOnWriteArrayList。
CopyOnWriteArrayListCopy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。
什么是CopyOnWrite容器CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。
这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。
CopyOnWrite的应用场景CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新。此时需要注意的是：

减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。
使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。

CopyOnWrite的缺点
内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象。
数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。

示例程序CopyOnWriteArrayList的添加操作之前我们介绍到CopyOnWrite是在元素发生改变时，复制出一个新的容器，然后...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/04</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/04/20181102-3/">
            
                <span>并发操作合集-7.并发容器：BlockingQueue</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

这一篇文章也会介绍一个并发容器，BlockingQueue。
BlockingQueue阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。
阻塞队列提供了四种处理方法:



方法\处理方式
抛出异常
返回特殊值
一直阻塞
超时退出




插入方法
add(e)
offer(e)
put(e)
offer(e,time,unit)


移除方法
remove()
poll()
take()
poll(time,unit)


检查方法
element()
peek()
不可用
不可用




抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。
返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null
一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。
超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。

Java里的阻塞队列JDK7提供了7个阻塞队列。分别是

LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
SynchronousQueue：一个不存储元素的阻塞队列。
DelayQueue：一个使用优先级队列实现的无界阻塞队列。
LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/04</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/02/20181102-2/">
            
                <span>并发操作合集-6.并发容器：ConcurrentHashMap</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

Java中提供了大量的并发容器，它们不同于并行容器（Vector，HashMap）。并发容器在确保线程安全的同时又具备较高的性能。
本章会介绍并发容器中最常用的ConcurrentHashMap。
ConcurrentHashMap简介ConcurrentMap接口继承自Map接口，实现了高吞吐量的同时线程安全。ConcurrentHashMap是ConcurrentMap的实现。基本的使用方式和Map相似，我们在这里涉及一些原理，以便更好地理解ConcurrentHashMap为何能实现高吞吐量。之后我们会看一下JDK1.8中新添加的方法。
ConcurrentHashMap原理整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。
简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。
concurrencyLevel：并行级别。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments。这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值。
关于它的初始化和get，put的实现原理，可以参考文末的链接。
ConcurrentMap新方法在下面的代码中，我们使用这个映射示例来展示那些JDK1.8提供新的方法：
12345ConcurrentMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();map.put("foo", "bar");map.put("han", "solo");map.put("r2", "d2");map.put("c3", "p0");
forEach()方法接受类型为BiConsumer的lambda表达式，以映射的键和值作为参数传递。它可以作为for-each循环的...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/02</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/02/20181102/">
            
                <span>并发操作合集-5.原子变量和volatile</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

本章主要讲解原子变量和volatile关键字的使用方式和使用场景，包括Java8中新加入的LongAdder和LongAccumulator。想要了解原子变量和volatile关键字，就必须先了解Java内存模型中的原子性和可见性。
可见性和原子性原子性在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
1234x = 10;         //语句1y = x;         //语句2x++;           //语句3x = x + 1;     //语句4
上面的语句中只有语句1是具备原子性的。也就是说其他三种语句在多线程环境下会出错。
我们想要让其他的三种语句都变成原子操作该怎么做？这时可以用到之前介绍的synchronized和锁，还有下面要介绍原子变量。
可见性可见性就是当一个变量被一个修改时，它的值会在主存中立即刷新，因此其他的所有线程都会主存中看到它的新值。而Java模型本身是不保证可见性的，也就是说上面的语句1,2,3,4本身都不具备可见性。
我们想要让上面4种语句都具有可见性该怎么做？同样可以用到之前介绍的synchronized和锁，还有下面要介绍volatile关键字。
原子变量AtomicIntegerjava.concurrent.atomic包包含了许多实用的类，用于执行原子操作。如果你能够在多线程中同时且安全地执行某个操作，而不需要synchronized关键字或锁，那么这个操作就是原子的。
本质上，原子操作严重依赖于比较与交换（CAS），它是由多数现代CPU直接支持的原子指令。这些指令通常比同步块要快。所以在只需要并发修改单个可变变量的情况下，我建议你优先使用原子类，而不是锁。
对于其它语言，一些语言的原子操作用锁实现，而不是原子指令。
现在让我们选取一个原子类，例如AtomicInteger：
12345678910111213private static AtomicInteger atomicInt = new AtomicInteger(0);    public static void testIncrement() throws InterruptedException &#12...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/02</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    
    
    
    
    
    <article class="index-post">
        <a class="abstract-title" href="/2018/11/01/20181101-2/">
            
                <span>并发操作合集-4.Lcok和Condition</span>
        </a>
        <div class="abstract-content">
            
🍤 并发操作合集系列 目录
🍕 并发操作合集系列 源代码

并发API支持多种显式的锁，它们由Lock接口规定，用于代替synchronized的隐式锁。锁对细粒度的控制支持多种方法，因此它们比隐式的监视器具有更大的开销。
Lock接口和synchronized关键字的差别两者的区别如下：



类别
synchronized
Lock




存在层次
Java的关键字，在jvm层面上
是一个类


锁的释放
1、以获取锁的线程执行完同步代码，释放锁2、线程执行发生异常，jvm会让线程释放锁
在finally中必须释放锁，不然容易造成线程死锁


锁的获取
假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待
分情况而定，Lock有多个锁获锁的方式，大致就是可以尝试获得锁，线程可以不用一直等待


锁状态
无法判断
可以判断


锁类型
可重入 不可中断 非公平
可重入 可中断 可公平（两者皆可）


性能
少量同步
大量同步



表中提到了所类型，先了解一下锁类型都有哪些：

可重入锁：在执行对象中所有同步方法不用再次获得锁
可中断锁：在等待获取锁过程中可中断
公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利
读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写

Lock接口定义的方法和使用
lock()：获取锁，如果锁被暂用则一直等待

unlock():释放锁

tryLock(): 注意返回类型是boolean，如果获取锁的时候锁被占用就返回false，否则返回true

tryLock(long time, TimeUnit unit)：比起tryLock()就是给了一个时间期限，保证等待参数时间

lockInterruptibly()：锁的获得方式，如果线程在获取锁的阶段进入了等待，那么可以中断此线程，先去做别的事


通过 以上的解释，大致可以解释在上个部分中“锁类型(lockInterruptibly())”，“锁状态(tryLock())”等问题，还有就是前面子所获取的过程我所写的“大致就是可以尝试获得锁，线程可以不会一直等待”用了“可以”的原因。
简单看一下比较常用的lock()和tryLock()方法的使用方式,启动两个线程来调用这些方法：
l...
        </div>
        <div class="abstract-post-meta">
            <!-- date  -->
            <div class="abstract-date">
                <span class="abstract-calander iconfont-archer">&#xe676;</span><span class="abstract-time">2018/11/01</span>
            </div>
            <!-- tags  -->
            
            <div class="abstract-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发">并发</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="并发操作合集">并发操作合集</a>
    
</div>
            
        </div>
    </article>
    
    <!-- paginator  -->
    
    <nav class="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/tags/并发/page/2/">2</a><a class="extend next" rel="next" href="/tags/并发/page/2/">NEXT &#62;</a>
    </nav>
    
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:nnkwrik@gmail.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="//github.com/nnkwrik" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title="wechat">
                  
                  <img class="profile-qr" src="/assets/qr.png">
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 19
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger">
                <span class="iconfont-archer search-icon">&#xe627;</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/09</span><a class="archive-post-title" href="/2018/11/09/20181109/">深入理解Java虚拟机-第1章-走近Java</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/05</span><a class="archive-post-title" href="/2018/11/05/20181105/">Java并发编程实战-第7章-取消与关闭</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104-5/">🍤 并发操作合集-目录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104-4/">并发操作合集-11.ThreadLocal</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104-3/">并发操作合集-10.Executor和线程池</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104-2/">并发操作合集-9.并发工具：Semaphore,CountDownLatch,CyclicBarrier</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181104/">并发操作合集-8.并发容器：CopyOnWriteArrayList</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/2018/11/04/20181102-3/">并发操作合集-7.并发容器：BlockingQueue</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/02</span><a class="archive-post-title" href="/2018/11/02/20181102-2/">并发操作合集-6.并发容器：ConcurrentHashMap</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/02</span><a class="archive-post-title" href="/2018/11/02/20181102/">并发操作合集-5.原子变量和volatile</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span><a class="archive-post-title" href="/2018/11/01/20181030-2/">并发操作合集-1.线程的生命周期</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span><a class="archive-post-title" href="/2018/11/01/20181031/">并发操作合集-2.状态转换方法：wait,notify,sleep,join,yield</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span><a class="archive-post-title" href="/2018/11/01/20181101/">并发操作合集-3.Synchronized使用指南</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span><a class="archive-post-title" href="/2018/11/01/20181101-2/">并发操作合集-4.Lcok和Condition</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/30</span><a class="archive-post-title" href="/2018/10/30/20181030/">Java并发编程实战-第6章-任务执行</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/29</span><a class="archive-post-title" href="/2018/10/29/20181029/">Java并发编程实战-第5章-基础构建模块</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href="/2018/10/28/20181028/">Java并发编程实战-第4章-对象的组合</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href="/2018/10/27/20181027/">Java并发编程实战-第3章-对象的共享</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/25</span><a class="archive-post-title" href="/2018/10/25/20181025/">Java并发编程实战-第2章-线程安全性</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="并发"><span class="iconfont-archer">&#xe606;</span>并发</span>
    
        <span class="sidebar-tag-name" data-tags="并发操作合集"><span class="iconfont-archer">&#xe606;</span>并发操作合集</span>
    
        <span class="sidebar-tag-name" data-tags="JVM"><span class="iconfont-archer">&#xe606;</span>JVM</span>
    
        <span class="sidebar-tag-name" data-tags="《深入理解Java虚拟机》"><span class="iconfont-archer">&#xe606;</span>《深入理解Java虚拟机》</span>
    
        <span class="sidebar-tag-name" data-tags="《Java并发编程实战》"><span class="iconfont-archer">&#xe606;</span>《Java并发编程实战》</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="并发操作合集"><span class="iconfont-archer">&#xe60a;</span>并发操作合集</span>
    
        <span class="sidebar-category-name" data-categories="读书笔记"><span class="iconfont-archer">&#xe60a;</span>读书笔记</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "曽生"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
     
    </body>
</html>


