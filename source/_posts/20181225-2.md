---
title: 慕课网-Java读源码之Netty深入剖析
typora-copy-images-to: 20181225
date: 2018-12-25 22:22:02
tags:
  - MySQL
  - 慕课网
  - 【Java读源码之Netty深入剖析】
categories:
  - 视频笔记
---

- 默认情况下,Netty服务端起多少线程?何时启动?
- Netty是如何解决jdk空轮询bug的?
- netty如何保证异步串行无所化?

# NioEventLoop

- NioEventLoop创建 
- NioEventLoop启动
- NioEventLoop执行逻辑

# NioEventLoop创建 

```
new NioEventLoopGroup()[线程数,默认2*cpu]
	|
	new ThreadPerTaskExecutor()[线程创建器]
	|
	for{newChlid()}[构造NioEventLoop]
	|
	chooserFactory.newChooser()[线程选择器]
```

跟踪`new NioEventLoopGroup()`

```java
    public NioEventLoopGroup(int nThreads, Executor executor) {
        this(nThreads, executor, SelectorProvider.provider());//加入selector
    }
---
    protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
    	//没传构造函数时,这里就是0.此时会默认cpu*2
        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
    }
---
    protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) {
    //放入创建线程选择器的factory
        this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);
    }
---
    
    protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                            EventExecutorChooserFactory chooserFactory, Object... args) {
    	//..
    	//创建线程选择器
        if (executor == null) {
            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
        }
		//构造NioEventLoop
        children = new EventExecutor[nThreads];
        for (int i = 0; i < nThreads; i ++) {
            children[i] = newChild(executor, args);
        }
		//线程选择器
        chooser = chooserFactory.newChooser(children);
		//..
    }
    
```

## ThreadPerTaskExcecutor

```java
 new ThreadPerTaskExecutor(newDefaultThreadFactory())
```

他会做两件事:为每一次执行任务都创建一个线程实体的工厂,定义NioEventLoop的名字

- 每一次执行任务都会创建一个线程实体
  ThreadPerTaskExcecutor中包含一个execute方法,代码如下

  ```java
  @Override
  public void execute(Runnable command) {
      threadFactory.newThread(command).start();//用参数factory每次都创建线程
  }
  ```

- NioEventLoop线程命名规则nioEventLoop-1--xx
  追一下它的实现方式.首先ThreadPerTaskExecutor的参数的factory:

  ```java
  protected ThreadFactory newDefaultThreadFactory() {
      return new DefaultThreadFactory(getClass());	//参数为NioEventLoop.class
  }
  ---跟
      public DefaultThreadFactory(Class<?> poolType, boolean daemon, int priority) {
      	//toPoolName,把NioEventLoop转成"nioEventLoop"
          this(toPoolName(poolType), daemon, priority);
      } 
  ```

   继续跟构造方法,到`DefaultThreadFactory#DefaultThreadFactory`就会看到

  ```java
  prefix = poolName + '-' + poolId.incrementAndGet() + '-'; 
  ```

  顺便看一下`DefaultThreadFactory#newThread`,就是之前`ThreadPerTaskExecutor`里面的那个.就会发现它里面创建了Thread,并且自定义了名字

  ```java
  Thread t = newThread(new DefaultRunnableDecorator(r), prefix + nextId.incrementAndGet()); 
  ```

`newThread`方法源码:

```java
protected Thread newThread(Runnable r, String name) {
    //也就是说,ThreadPerTaskExecutor实际上执行的是对java线程进行封装后的线程.而不是原生的
    return new FastThreadLocalThread(threadGroup, r, name);
}
```

`FastThreadLocalThread`继承于Thread,对ThreadLocal做了些优化,并且自己包装了ThreadLocalMap.



## newChilld()

接着看在NioEventLoop中做的第二件事:通过for{newChlid()}为每个处理线程(默认cpu*2)创建NioEventLoop.

它主要做这三件事:

- 保存线程执行器ThreadPerTaskExecutor
- 创建一个MpscQueue
- 创建一个selector

```java
 newChild(executor, args) // 参数executor就是上面创建的ThreadPerTaskExecutor.
     					//这个方法会构造NioEventLoop
```

跟踪到NioEventLoop的构造方法

```java
NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,
             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {
    //父类
    super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);
    
    provider = selectorProvider;
    selector = openSelector();	//对NioEventLoop绑定一个selector轮询器
    selectStrategy = strategy;
}
```

openSelector()就是通过`provider.openSelector();`获取轮训器后保存

继续跟踪父类构造方法

```java
protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,
                                    boolean addTaskWakesUp, int maxPendingTasks,
                                    RejectedExecutionHandler rejectedHandler) {
    super(parent);
    this.addTaskWakesUp = addTaskWakesUp;
    this.maxPendingTasks = Math.max(16, maxPendingTasks);
    //保存线程执行器,也就是ThreadPerTaskExecutor.
    //每个NioEventLoop都会调用这个ThreadPerTaskExecutor创建执行线程
    this.executor = ObjectUtil.checkNotNull(executor, "executor");
    //taskQueue:外部线程执行netty任务的时候.不会直接让NioEventLoop执行,而是塞到队列里面让它执行
    //创建taskQueue
    taskQueue = newTaskQueue(this.maxPendingTasks);
    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, "rejectedHandler");
}
```

看一下这个`newTaskQueue()`(`io.netty.channel.nio.NioEventLoop#newTaskQueue`)

```java
@Override
protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {
    //是通过MpscQueue创建
    return PlatformDependent.newMpscQueue(maxPendingTasks);
} 
```

`MPSC` :  multiProducer(指外部线程)-SingleConsumer (netty的处理线程)

## chooserFactory.newChooser()

完成了NioEventLoop[]的创建.接着看在NioEventLoop中做的第三件事:通过chooserFactory.newChooser()构造线程选择器.

目的是给新连接绑定对应的NioEventLoop,通过`io.netty.util.concurrent.MultithreadEventExecutorGroup#next`绑定.

他是如何选择线程进行绑定的?很简单,当第一个新连接进来的时候绑定NioEventLoop[]中的第一个,第二个连接则绑定第二个,超过NioEventLoop[]大小后又回到第一个.但netty对此进行了优化:

```
isPowerOfTwo()[判断NioEventLoop[]的个数是否是2的幂,如2,4,8,16]
	|
	PowerOfTwoEventExecutorChooser[是2的幂:优化]
		|
		index++ & (length - 1)
	|
	GenericEventChooser[不是2的幂:普通]
		|
		abs(index++ % length)
```

看一下步骤:

```java
chooserFactory.newChooser(children); //参数children就是刚才通过for创建的NioEventLoop的数组
---
    @Override
    public EventExecutorChooser newChooser(EventExecutor[] executors) {
    	//executors指NioEventLoop[]
        if (isPowerOfTwo(executors.length)) {	//判断2的幂
            return new PowerOfTowEventExecutorChooser(executors);
        } else {
            //
            return new GenericEventExecutorChooser(executors);
        }
    }
```

关于GenericEventExecutorChooser:

类里面有个next方法:DefaultEventExecutorChooserFactory.GenericEventExecutorChooser#next

就是单纯的`executors[Math.abs(idx.getAndIncrement() % executors.length)];`

关于PowerOfTowEventExecutorChooser:

类里面有个next方法:DefaultEventExecutorChooserFactory.PowerOfTowEventExecutorChooser#next

返回的是`executors[idx.getAndIncrement() & executors.length - 1]`

# NioEventLoop执行

nioEventLoop在线程被首次创建的时候会通过run方法执行 (`SingleThreadEventExecutor.this.run()`).Netty基本组件那次的笔记里有涉及到.

## NioEventLoop.run()

```
run() -> for(;;)
	|
	select()[检查是否有io事件]
	|
	processSelectKeys()[处理io事件]
	|
	runAllTask()[处理异步任务队列,就是上一节最后说的taskQueue]
	
```

实际代码`io.netty.channel.nio.NioEventLoop#run`

```java
@Override
protected void run() {
    for (;;) {
        switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {
            case SelectStrategy.CONTINUE:
                continue;
            case SelectStrategy.SELECT:
                select(wakenUp.getAndSet(false));//轮询io事件
                //一个nioEventLoop对应了一个selector,轮询注册到这个selector上的io事件
                //..
        }

        //注意有两个processSelectedKeys();
        //ioRatio :控制processSelectedKeys()和runAllTasks()的执行时间,默认50
        final int ioRatio = this.ioRatio;
        if (ioRatio == 100) {
            try {
                processSelectedKeys();//处理io事件
            } finally {
                runAllTasks();//处理外部线程放到taskQueue中的任务
            }
        } else {//默认执行这段
            final long ioStartTime = System.nanoTime();
            try {
                processSelectedKeys();
            } finally {
                final long ioTime = System.nanoTime() - ioStartTime;
                //参数为processSelectedKeys()花费的时间
                runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
            }
        }
        //..
}
```

## select()方法执行逻辑

- deadline以及任务穿插逻辑处理

  - deadline:根据nioEventLoop是否有定时任务
  - 当前是否有异步任务

  满足上面任意一个.select()就会停止并退出

- 阻塞式select,

  - 没有到deadLine并且任务队列为空的情况
  -  默认是1秒钟,外部线程也可以在这时把阻塞操作唤起

- 避免jdk空轮询的bug

**deadline以及任务穿插逻辑处理**

```java
case SelectStrategy.SELECT:
	select(wakenUp.getAndSet(false));//参数获取是否是唤醒状态,并之后把他设为false
```

先看一下它的源码(`io.netty.channel.nio.NioEventLoop#select`):

```java
private void select(boolean oldWakenUp) throws IOException {
    Selector selector = this.selector;
    try {
        int selectCnt = 0;
        long currentTimeNanos = System.nanoTime();//当前时间
        //定时任务队列:按照任务的截止时间正序排序的队列,
        //计算当前第一个定时任务的截止时间,当前的select()不能超过这个时间
        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);
        for (;;) {
            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;
            if (timeoutMillis <= 0) {//已经超时了
                if (selectCnt == 0) {
                    selector.selectNow();	//非阻塞的select方法
                    selectCnt = 1;
                }
                break;//退出
            }
            
            //hasTasks(): 判断异步队列中是否有任务要执行
            //实际在SingleThreadEventExecutor#hasTasks中判断taskQueue是否为空
            if (hasTasks() && wakenUp.compareAndSet(false, true)) {
                selector.selectNow();	//非阻塞的select方法
                selectCnt = 1;
                break;//退出
            }
```

**阻塞式select**

对应run()中的

```java
int selectedKeys = selector.select(timeoutMillis);//参数为本次可以进行select的最大时间,默认1秒
selectCnt ++; //表示当前已经轮询了selectCnt次
//轮询到了事件||是唤醒的状态||被唤醒了||异步队列有任务||定时任务队列有任务
if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {
    //就是说有事干了.返回
    break;
}
```

**避免jdk空轮询的bug**

jdk的空轮询的bug会导致cpu到100%,

继续看run()

```java
long time = System.nanoTime();
//已经超过了截止时间(默认1),意思就是已经正常完成了一次select()但没有轮询到东西
if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {
    selectCnt = 1;
//select()没有阻塞立即返回了,可能触发了空轮询
} else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&
           //这个值是512,也就是说512次轮询的结果都为空
           selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {

    rebuildSelector();	//调用这个避免下一次空轮询继续发生
    //把老的selectedKeys都注册到一个新的selector里面去,替换当前的selector
    
    selector = this.selector;
    selector.selectNow();	//重新进行select,成功解决
    selectCnt = 1;
    break;
}
```



看一下避免下一次空轮询继续发生 的`rebuildSelector();`调用:

```java
public void rebuildSelector() {
    final Selector oldSelector = selector;
    final Selector newSelector;

    newSelector = openSelector();	//创建新的selector

    for (;;) {
        try {
            for (SelectionKey key: oldSelector.keys()) {//拿到旧的key
                Object a = key.attachment();//之前讲过,是netty包装的channel

                int interestOps = key.interestOps();//注册的事件
                key.cancel();//取消旧的
                //创建到新的上面
                SelectionKey newKey = key.channel().register(newSelector, interestOps, a);
                if (a instanceof AbstractNioChannel) {
                    //attachment是netty包装的channel的话,加入key(之前说过)    
                    ((AbstractNioChannel) a).selectionKey = newKey;
                }
            }
```

