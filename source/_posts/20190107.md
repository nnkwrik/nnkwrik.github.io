---
title: Netty源码剖析-ByteBuf
typora-copy-images-to: 20190107
date: 2019-01-07 11:35:04
tags:
  - MySQL
  - 慕课网
  - 【Java读源码之Netty深入剖析】
categories:
  - 视频笔记
---

- 内存的类别有哪些
- 如何减少多线程内存分配之间的竞争
- 不同大小的内存是如何进行分配的

# ByteBuf

- 内存与内存管理器的抽象
- 不同规格大小和不同类别的内存的分配策略
- 内存的回收过程

# ByteBuf结构以及重要API

## ByteBuf的结构

```java

 *      +-------------------+------------------+------------------+
 *      | discardable bytes |  readable bytes  |  writable bytes  |
     		无效的				可以读的空间			可以写的空间
 *      +-------------------+------------------+------------------+
 *      |                   |                  |                  |
 *      0      <=      readerIndex   <=   writerIndex    <=    capacity
```

ByteBuf中三个重要的指针

- readIndex..表明读数据从这个指针开始
- writeIndex..表明如果要写数据的话就从这个指针开始写
- capacity 
- `maxCapacity()`可扩容的最大容量,当capacity不够时就会进行扩容.要是大于`maxCapacity()`就拒绝

## read,write,set方法

提供了很多read开头的方法,如`readInt();`

- `readByte()`从readerIndex开始往后读1个字节
- `readInt();`从readerIndex开始往后读4个字节...

write的API也和read相同,从指针开始往后设置.

除了这两个之外还有set的API如`setInt();`,它的功能是把第几个索引设置成目的的值 

```java
public abstract ByteBuf setByte(int index, int value);
```

它不会移动任何指针 

## mark和reset方法

```java
public abstract ByteBuf markReaderIndex();
public abstract ByteBuf resetReaderIndex();
```

通过read的API读取数据时,指针会向后移动.如果不想这样  可以在read之前先用mark记录指针位置,read完后用reset复原指针.`markWriterIndex()`也同理

##  其他常用API

```java
public abstract int readableBytes();//this.writerIndex - this.readerIndex 
public abstract int writableBytes();//this.capacity - this.writerIndex
public abstract int maxWritableBytes();//this.maxCapacity - this.writerIndex
```

# ByteBuf分类

![1547806307918](20190107/1547806307918.png)

## AbstractByteBuf

基本骨架的实现,读写的具体实现方法仍是抽象,这些抽象方法为`_`开头

保存读写指针

```java
    int readerIndex;
    int writerIndex;
    private int markedReaderIndex;
    private int markedWriterIndex;
    private int maxCapacity;
```

他实现的readByte

```java
    @Override
    public byte readByte() {
        checkReadableBytes0(1);
        int i = readerIndex;//获取当前写指针
        byte b = _getByte(i);//从这个写指针读一个字节,这里是抽象方法
        readerIndex = i + 1;//写指针后移
        return b;
    }
```

它实现的writeByte

```java
    @Override
    public ByteBuf writeByte(int value) {
        //保证能写
        ensureAccessible();
        ensureWritable0(1);
        //这里是抽象方法,表示写入指针的位置,写完后指针后移
        _setByte(writerIndex++, value);
        return this;
    }
```

## ByteBuf实现的分类

### Pooled和Unpooled

Pooled:把预先在内存中设置好的内存封装为ByteBuf
Unpooled:直接调用系统的API向操作系统申请一块内存 

### Unsafe和非Unsafe

Unsafe:可以拿到对象的内存地址,通过内存地址进行读写操作.直接调用JDK的Unsafe对ByteBuf进行读写
非Unsafe:不依赖JDK的Unsafe对象
如`PooledUnsafeHeapByteBuf#_getByte`

```java
    @Override
    protected byte _getByte(int index) {
        //通过内存去取值
        //memory:ByteBuf分配内存的首地址,index:偏移地址
        return UnsafeByteBufUtil.getByte(memory, idx(index));
    }
---
    static byte getByte(byte[] data, int index) {
    	//最终调用Unsafe对象获取
        return UNSAFE.getByte(data, BYTE_ARRAY_BASE_OFFSET + index);
    }
```

  相反`PooledHeapByteBuf#_getByte` 

```java
    @Override
    protected byte _getByte(int index) {
        return HeapByteBufUtil.getByte(memory, idx(index));
    }
---
    static byte getByte(byte[] memory, int index) {
    //直接通过数组保存
        return memory[index];
    }
```

### Heap和Direct

**Heap:在对上进行内存分配.GC管理**
**Direct:通过JDK的API在JVM外分配,没有GC**
UnpooledHeapByteBuf中 

```java
    byte[] array;//通过数组操作
```

而UnpooledDirectByteBuf中

```java
private ByteBuffer buffer;//ByteBuf对象,这个是JDK底层的ByteBuf
```

它的_getByte()

```java
    @Override
    protected byte _getByte(int index) {
        return buffer.get(index);
    }
```

这个JDK的ByteBuffer是如何分配的?

在UnpooledDirectByteBuf的构造方法:

```java
    protected UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {
        this.alloc = alloc;
        setByteBuffer(ByteBuffer.allocateDirect(initialCapacity));//JDK提供的API 
    }
---
    public static ByteBuffer allocateDirect(int capacity) {
        return new DirectByteBuffer(capacity);//分配堆外内存
    }
```

# ByteBufAllocator分析

## ByteBufAllocator功能

所有类型的ByteBuf最终都是由ByteBufAllocator分配出来,它相当于Netty中的内存管理器.

看一下它有哪些功能

```java
public interface ByteBufAllocator {

    ByteBufAllocator DEFAULT = ByteBufUtil.DEFAULT_ALLOCATOR;
    
    //分配一块内存.依赖于Direct或heap的具体实现
    ByteBuf buffer();
    ByteBuf buffer(int initialCapacity);
    ByteBuf buffer(int initialCapacity, int maxCapacity);
	
    //分配一块内存,倾向于io,推荐用Direct实现
    ByteBuf ioBuffer();
    ByteBuf ioBuffer(int initialCapacity);
    ByteBuf ioBuffer(int initialCapacity, int maxCapacity);
	
     //在堆上分配一块内存
    ByteBuf heapBuffer();
    ByteBuf heapBuffer(int initialCapacity);
    ByteBuf heapBuffer(int initialCapacity, int maxCapacity);

    //在堆外分配一块内存
    ByteBuf directBuffer();
    ByteBuf directBuffer(int initialCapacity);
    ByteBuf directBuffer(int initialCapacity, int maxCapacity);
	
    //允许不单独基于堆或堆外实现的方式分配内存,可以把两个ByteBuf合并到一起成compositeBuffer
    //用得少
    CompositeByteBuf compositeBuffer();
    CompositeByteBuf compositeBuffer(int maxNumComponents);
    CompositeByteBuf compositeHeapBuffer();
    CompositeByteBuf compositeHeapBuffer(int maxNumComponents);
    CompositeByteBuf compositeDirectBuffer();
    CompositeByteBuf compositeDirectBuffer(int maxNumComponents);

    boolean isDirectBufferPooled();

    int calculateNewCapacity(int minNewCapacity, int maxCapacity);
 }

```

可以看到ByteBufAllocator只区分了Direct或heap,没有说道其他的几种分类方式

## AbstractByteBufAllocator抽象实现

 如buffer()的实现

```java
    @Override
    public ByteBuf buffer() {
        if (directByDefault) {
            return directBuffer();
        }
        return heapBuffer();
    }
```

同时具备direct和heap分配的两种功能,下面是`directBuffer()`

```java
    @Override
    public ByteBuf directBuffer(int initialCapacity, int maxCapacity) {
        if (initialCapacity == 0 && maxCapacity == 0) {
            return emptyBuf;
        }
        validate(initialCapacity, maxCapacity);
        return newDirectBuffer(initialCapacity, maxCapacity);//而这个部分是抽象的
    }
---
    protected abstract ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity);
	protected abstract ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity);
```

也就是说具体new出来的DirectBuffer是pooled还是unpooled,是由子类实现.实现这个方法的类有

- PooledByteBufAllocator
- UnPooledByteBufAllocator

反之,AbstractByteBufAllocator已经实现了这两个方法之外的所有方法

## ByteBufAllocator两大子类

![1547810810218](20190107/1547810810218.png)

回顾一下

- Pooled:从已经分配好的内存中取一段
- UnPlooed:直接调用系统API分配一块新的内存

那么unsafe和非unsafe是什么谁实现的

对于unsafe,netty会自动判别.如过能拿到unsafe对象就分配unsafe的byteBuf,如果拿不到则会分配非unsafe的byteBuf

比如UnpooledByteBufAllocator是这样实现newHeapBuffer的:

```java
@Override
protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) {
    //判断是否有unsafe对象,然后返回相应的ByteBuf
    return PlatformDependent.hasUnsafe() ? new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity)
        : new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);
}
```

## UnpooledByteBufAllocator分析

### Heap内存分配

`UnpooledByteBufAllocator#newHeapBuffer`如下

```java
@Override
protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) {
    //netty自动判断是否创建unsafe 
    return PlatformDependent.hasUnsafe() ? new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity)//先看这个
        : new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);
}
```

关于UnpooledUnsafeHeapByteBuf的创建,可以看到`UnpooledUnsafeHeapByteBuf`是`UnpooledHeapByteBuf`的子类,而他的构造函数如下

```java
    UnpooledUnsafeHeapByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {
        super(alloc, initialCapacity, maxCapacity);
    }
```

也就是说它的创建过程和`UnpooledHeapByteBuf`是完全相同的,他们都需要去创建一个数组作为存储空间

```java
    protected UnpooledHeapByteBuf(ByteBufAllocator alloc,
                                  int initialCapacity,//初始的capacity,
                                  int maxCapacity) {	//最多可以扩容到多少capacity
        //0,0 = readIndex,writeIndex
        this(alloc, new byte[initialCapacity], 0, 0, maxCapacity);
    }
---
    private UnpooledHeapByteBuf(
            ByteBufAllocator alloc, byte[] initialArray, int readerIndex, int writerIndex, int maxCapacity) {
        super(maxCapacity);

        this.alloc = alloc;
        setArray(initialArray);//把新创建的byte数组保存到成员变量
        setIndex(readerIndex, writerIndex);//同样把这里两个指针保存到成员变量
    }
```

那么`UnpooledUnsafeHeapByteBuf`和`UnpooledHeapByteBuf`的实现的区别是什么?

关于`UnpooledHeapByteBuf`,能看出它是直接从Byte数组中取出元素

(非Unsafe:不依赖JDK的Unsafe对象)

```java
    @Override
    protected byte _getByte(int index) {
        return HeapByteBufUtil.getByte(array, index);
    }
---
    static byte getByte(byte[] memory, int index) {
        return memory[index];//
    }
```

而`UnpooledUnsafeHeapByteBuf`,它最终调用unsafe对象去获取元素

(Unsafe:可以拿到对象的内存地址,通过内存地址进行读写操作.直接调用JDK的Unsafe对ByteBuf进行读写)

```java
    @Override
    protected byte _getByte(int index) {
        return UnsafeByteBufUtil.getByte(array, index);
    }
---
    static byte getByte(byte[] data, int index) {
        return UNSAFE.getByte(data, BYTE_ARRAY_BASE_OFFSET + index);
    }
```

### direct内存分配

也就是堆外内存分配 

回到`UnpooledByteBufAllocator`的`newDirectBuffer()`

```java
    @Override
    protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {
        //也是先判断unsafe
        ByteBuf buf = PlatformDependent.hasUnsafe() ?
                UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :
                new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);

        return disableLeakDetector ? buf : toLeakAwareBuffer(buf);
    }
```

先看`UnpooledDirectByteBuf`的创建

```java
    protected UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {
        super(maxCapacity);
 
        this.alloc = alloc;
        //用JDK-API分配堆外内存
        setByteBuffer(ByteBuffer.allocateDirect(initialCapacity));//把创建的JDKBuffer保存到成员变量
    }
```

而上面的`newUnsafeDirectByteBuf`创建的unsafe的direct是做了什么

```java
    static UnpooledUnsafeDirectByteBuf newUnsafeDirectByteBuf(
            ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {
        //创建了UnpooledUnsafeDirectByteBuf
        return new UnpooledUnsafeDirectByteBuf(alloc, initialCapacity, maxCapacity);
    }
---
    //和UnpooledDirectByteBuf相似
    protected UnpooledUnsafeDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {
        super(maxCapacity);

        this.alloc = alloc;
    	//同样是调用ByteBuffer.allocateDirect(initialCapacity);
        setByteBuffer(allocateDirect(initialCapacity), false);
    }
```

与UnpooledDirectByteBuf的内存分配步骤相同,不同在于它的`setByteBuffer()`步骤

```java
    final void setByteBuffer(ByteBuffer buffer, boolean tryFree) {

        this.buffer = buffer;//和UnpooledDirectByteBuf相同保存创建的JDKBuffer
        //不同之处 : 把这个buffer的内存地址保存到memoryAddress中
        memoryAddress = PlatformDependent.directBufferAddress(buffer);
        tmpNioBuf = null;
        capacity = buffer.remaining();
    }
```

这个`PlatformDependent.directBufferAddress`会通过`UNSAFE.getLong(object, fieldOffset);`获取内存地址

以后我们通过getByte读值的时候会通过这里保存的`memoryAddress`去读值,看一下它的getByte

```java
    @Override
    protected byte _getByte(int index) {
        return UnsafeByteBufUtil.getByte(addr(index));//算内存地址 memoryAddress + index 
    }
---
    //通过Unsafe和内存地址获取
    static byte getByte(long address) {
        return UNSAFE.getByte(address);
    }
```

而相比之下,`UnpooledDirectByteBuf`则是

```java
    @Override
    protected byte _getByte(int index) {
        return buffer.get(index);//直接用JDK的buffer的get去获取
    }
```

# 小结

### ByteBuf分类

- **按内存的分配方式分类**

| Pooled                          | Unpooled                    |
| ------------------------------- | --------------------------- |
| 利用已分配的内存空间构建ByteBuf | 重新分配内存空间构建ByteBuf |

- **按操作方式分类**

| Unsafe                                     | 非Unsafe                    |
| ------------------------------------------ | --------------------------- |
| 通过Unsafe对象,用内存地址对ByteBuf进行操作 | 用其他方式对ByteBuf进行操作 |

- **按所在空间分类**

| Heap   | Direct                    |
| ------ | ------------------------- |
| 堆内存 | 堆外内存,创建JDK的ByteBuf |

### 对于Unpooled

他们的`_getByte()`分别是如何获取元素的

|            | Unsafe                             | 非Unsafe                   |
| ---------- | ---------------------------------- | -------------------------- |
| **Heap**   | Unsafe对象从堆内地址获取元素       | 从数组直接获取索引元素     |
| **Direct** | Unsafe对象从计算堆外地址后获取元素 | 从JDK的ByteBuf直接获取元素 |

### 3个维度的分类分别在什么时候决定

1. Allocator子类决定Pooled还是UnPooled
2. 调用它的newHeapBuffer还是newDirectBuffer决定Heap还是Direct
3. 调用hasUnsafe()决定时Unsafe还是非Unsafe